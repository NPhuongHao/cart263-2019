MAYORING || Nguyen Phuong Hao

For this final project, I was looking for an idea that can harmonize between my interests in video games and my capacity to handle more complex coding. While I was studying different mechanisms, I have stumbled upon Spoopy Squad's Underhand, a strategy card game where player handles different resources in order to reach an end goal. Underhand's mechanism is fascinating in its apparent simplicity, all the while involving flexible mathematical/statistical calculation. For that reason, I became interested in figuring out its functioning and apply it into another setting. Thus, MAYORING is born.

MAYORING's concept and mechanisms share many similarities with Underhand. In this game, you play as the mayor of a small village near the forest. Pressured by wars and the nearby wolfs, the mayor signed a contract with the Big Wolf, in order to minimize the damage. The mayor has to manage 4 main resources: Food, Money, Livestock and Villager; one special resource (wolf's bane) in order to win the round with the Big Wolf and a risk factor (that would lead to an attack on the village if it gets too high). My objectives are: 1) To illustrate the spirit of the original; 2) To balance between players choices and thus possible outcomes of the game as accurately as possible and 3) To work my way around advanced problems that I have yet had the skills for.

The mechanism can be summarized as following: an event is chosen from the JSON arrays; the corresponding options will then be presented, each option having a set of requirements and rewards. The player chooses an option by giving out sufficient resources according to said option’s requirements, and will receive a new set of resources as rewards. If the player is forced to choose an option that leads to the ending, the game will be lost.

The challenges behind (and appeal of) this project are mostly mathematical. There are different questions with Underhand that I looked forward to resolve (that I managed to, albeit in simplified methods)
  1.	Some of the requirements change according to the player’s current resources, and cannot be stored in a simple array. To solve this, I divided the modifying factors of each option into two classes: Requirements and Rewards. With this solution, the altering functions will only affect the former class, and it’s also easier to verify the player’s answer.
  2.	In some cases the player can choose between two types of resources for a single option. This complicates the process of registering requirements (mixed, for example : 2 Food/Money) and checking if the player’s answer (separated, for example: 1 Food + 1 Money) satisfies said requirements. This problem is partly solved by the solution for 1). I also added a new name for the mixed requirements. While this can be taxing and manual, it allows easier access while verifying the player’s answer and can also prove more flexible in future updates.
  3.	The game can also take away a number of player’s random resources (for example: the “Greed” event). They are considered requirements, but are not displayed on screen and the player cannot choose which resource to discard. For this problem, I created a separate function called takeRandomCards() that will automatically take away the player’s resources.
  4.	Some events are less likely to occur than others. This is the issue of game balancing, which I have not been capable to solve thoroughly.

As for the visual, I followed a simple and minimalistic style, focusing on arranging the content in a clear and playable structure. The music is a tavern song from Bioware’s Dragon Age: Inquisition, in order to provide some aspect of my desired ambience.
